{
  "hash": "c5181a4f19a96f1339267e8585ac0be5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Joint analysis of E2a and E2b\"\nauthor: \"Ven Popov\"\ndate: \"2023-08-30\"\ndate-modified: \"2023-08-30\"\n---\n\n\n\n::: {.callout-note}\nThese are legacy analyses scripts from my older project structure. The scripts are kept here for reference and reproducibility purposes until I completely transition to the new structure. I want to replicate the analysis in the new project structure to make sure everything is working as expected. Nowadays I also have better solutions than `if(file.exists())` for managing the data and model fits, so I will update the script accordingly.\n:::\n\n\n\n## Load and clean data\n\nJoint analysis of Experiment 2a and 2b. Load libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lme4)\nlibrary(Rmisc)\nlibrary(tidyverse)\nlibrary(here)\nlibrary(brms)\n\ndodge <- position_dodge(1)\ntheme_set(theme_dark(base_size = 11))\n```\n:::\n\n\n\n\nLoad and combine data that was preprocessed with David's script.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# if the script has been run before, preload the data and model fits\nR_output_file <- here::here('output/exp2.RData')\n\nif (!file.exists(R_output_file)) {\n  exp2a <- read.csv(here::here('data/Expmt2a-PreReg/Processed/LongFormAnalysisData.csv'))\n  exp2b <- read.csv(here::here('data/Expmt2b-PreReg/Processed/LongFormAnalysisData.csv'))\n  exp2a$exp <- '2a'\n  exp2b$exp <- '2b'\n  exp2b$participant <- exp2b$participant\n  dat <- bind_rows(exp2a,exp2b)\n  \n  # Apply David's trimming script\n  procTrim <- dat %>% \n    filter(ProportionTonesCorrect == 1) %>% \n    mutate(rt = rt*1000) %>%  # Make RTs milliseconds\n    group_by(participant) %>% # grouping by participant so SD per participant calculated - similar to perParticipant = True in Trimr\n    filter(rt >= 200)%>%      # remove anything <200ms as this likely means they were anticipating response rather than reacting - same as Joseph & Morey 2021\n    filter(rt < 5000) %>%       \n    filter(abs(rt - mean(rt))/sd(rt) <= 3) \n  \n  # This just gives a quick summary count of amount of data before and after trimming.\n  nrow(dat) #original number\n  nrow(procTrim) #number remaining\n  nrow(dat) - nrow(procTrim) #number removed  \n  \n  ##Rename variables to align with previous research\n  procTrim[procTrim == \"LeadTone_RT1\"] <- \"Lead-in-4\"\n  procTrim[procTrim == \"LeadTone_RT2\"] <- \"Lead-in-3\"\n  procTrim[procTrim == \"LeadTone_RT3\"] <- \"Lead-in-2\"\n  procTrim[procTrim == \"LeadTone_RT4\"] <- \"Lead-in-1\"\n  procTrim[procTrim == \"MainTone_RT1\"] <- \"List-1\"\n  procTrim[procTrim == \"MainTone_RT2\"] <- \"List-2\"\n  procTrim[procTrim == \"MainTone_RT3\"] <- \"List-3\"\n  procTrim[procTrim == \"MainTone_RT4\"] <- \"List-4\"\n  procTrim[procTrim == \"MainTone_RT5\"] <- \"List-5\"\n  procTrim[procTrim == \"MainTone_RT6\"] <- \"List-6\"\n  procTrim[procTrim == \"MainTone_RT7\"] <- \"List-7\"\n  procTrim[procTrim == \"MainTone_RT8\"] <- \"List-8\"\n  procTrim[procTrim == \"MainTone_RT9\"] <- \"List-9\"\n  \n  procTrim <- procTrim %>%  \n    mutate(procPeriod = case_when(grepl(\"Lead-in\", procPos) ~ \"Lead-in\",\n                                  grepl(\"List\", procPos) ~\"Load\")) %>% \n    mutate(procPos = factor(procPos, levels = c(\"Lead-in-4\", \"Lead-in-3\", \"Lead-in-2\", \"Lead-in-1\", \"List-1\", \"List-2\", \"List-3\", \"List-4\", \"List-5\", \"List-6\", \"List-7\", \"List-8\", \"List-9\"))) %>%\n    mutate(ListLength = as.factor(ListLength))%>%\n    mutate(serial_position_abs = as.numeric(gsub('List-','', procPos)),\n           serial_position_rel = serial_position_abs-recallamount) %>% \n    mutate(recallamount = as.factor(recallamount)) %>% \n    ungroup()\n} else {\n  load(R_output_file)\n  R_output_file <- here::here('output/exp2.RData')\n}\n```\n:::\n\n\n\n\n\n## Data Visualisation\n\nWe can now plot our tidied and trimmed data. We will relabel some variables and then calculate the summary statistics before plotting.\n\nReproduce the basic plot for both experiments (code from David's script)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Means for plot, with within-participant SEMs\ngraphRT <- summarySEwithin(ungroup(procTrim), measurevar = \"rt\", withinvars = c(\"ListLength\",\"recallamount\", \"procPos\", \"procPeriod\"), betweenvars=\"exp\", idvar=\"participant\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAutomatically converting the following non-factors to factors: exp, procPeriod\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(graphRT, aes(procPos, rt, group=interaction(procPeriod, ListLength))) + \n  geom_point(data = graphRT, mapping = aes(x = procPos, y = rt, color = ListLength), size = 2, alpha = 1/3, position = dodge) +\n  geom_line(data = graphRT, mapping = aes(x = procPos, y = rt, colour = ListLength, group = interaction(procPeriod, ListLength)), position = dodge) + \n  geom_errorbar(aes(ymin=rt-se, ymax=rt+se, colour = ListLength), width=.15, position=position_dodge(.9))+\n  facet_grid(exp~recallamount, scales=\"free\") + \n  scale_colour_manual(values = viridisLite::viridis(8, direction = -1), name=\"List Length\") + \n  xlab(\"Serial Position\") + \n  ylab(\"Mean Response Time (ms)\") +\n  # scale_y_continuous(breaks=seq(600, 1400, 50), limits = c(600, 1400))+\n  #ylim(250, 800) +\n  theme(axis.text.x = element_text(angle = 70, hjust=1)) \n```\n\n::: {.cell-output-display}\n![](JointAnalyses-2ab-Ven_files/figure-html/PlotGraphs-1.png){width=672}\n:::\n:::\n\n\n\n\nPlot RT collapsed over list-length and as a function of serial position relative to N. Position 0 means the 2nd item in recall2 condition or the 4th item in the recall4 condition. Separately for both experiments\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Means for plot, with within-participant SEMs\ngraphRT <- procTrim %>% \n  filter(procPeriod == \"Load\") %>% \n  summarySEwithin(measurevar = \"rt\", withinvars = c(\"recallamount\", \"serial_position_rel\"), betweenvars=\"exp\", idvar=\"participant\") %>% \n  mutate(serial_position_rel = as.numeric(as.character(serial_position_rel)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAutomatically converting the following non-factors to factors: exp, serial_position_rel\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(graphRT, aes(serial_position_rel, rt)) + \n  geom_point(data = graphRT, mapping = aes(x = serial_position_rel, y = rt, color=as.factor(recallamount), group=as.factor(recallamount)), size = 2, alpha = 1/3) +\n  geom_line(data = graphRT, mapping = aes(x = serial_position_rel, y = rt, color=as.factor(recallamount), group=as.factor(recallamount))) + \n  geom_errorbar(aes(ymin=rt-se, ymax=rt+se, color=as.factor(recallamount), group=as.factor(recallamount)), width=.15)+\n  scale_colour_manual(values = viridisLite::viridis(2, direction = -1), name=\"List Length\") + \n  xlab(\"Relative Serial Position\") + \n  ylab(\"Mean Response Time (ms)\") +\n  # scale_y_continuous(breaks=seq(600, 1400, 50), limits = c(600, 1400))+\n  #ylim(250, 800) +\n  theme(axis.text.x = element_text(angle = 70, hjust=1))+\n  facet_grid(exp~., scales=\"free\") +\n  geom_vline(xintercept = 0.5, color=\"red\")\n```\n\n::: {.cell-output-display}\n![](JointAnalyses-2ab-Ven_files/figure-html/unnamed-chunk-3-1.png){width=480}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Means for plot, with within-participant SEMs\ngraphRT <- procTrim %>% \n  filter(procPeriod == \"Load\") %>% \n  summarySEwithin(measurevar = \"rt\", withinvars = c(\"recallamount\", \"serial_position_rel\", \"which_n_first\"), betweenvars=\"exp\", idvar=\"participant\") %>% \n  mutate(serial_position_rel = as.numeric(as.character(serial_position_rel)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAutomatically converting the following non-factors to factors: exp, serial_position_rel, which_n_first\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(graphRT, aes(serial_position_rel, rt)) + \n  geom_point(data = graphRT, mapping = aes(x = serial_position_rel, y = rt, color=as.factor(recallamount), group=as.factor(recallamount)), size = 2, alpha = 1/3) +\n  geom_line(data = graphRT, mapping = aes(x = serial_position_rel, y = rt, color=as.factor(recallamount), group=as.factor(recallamount))) + \n  geom_errorbar(aes(ymin=rt-se, ymax=rt+se, color=as.factor(recallamount), group=as.factor(recallamount)), width=.15)+\n  scale_colour_manual(values = viridisLite::viridis(2, direction = -1), name=\"List Length\") + \n  xlab(\"Relative Serial Position\") + \n  ylab(\"Mean Response Time (ms)\") +\n  # scale_y_continuous(breaks=seq(600, 1400, 50), limits = c(600, 1400))+\n  #ylim(250, 800) +\n  theme(axis.text.x = element_text(angle = 70, hjust=1))+\n  facet_grid(exp~which_n_first, scales=\"free\") +\n  geom_vline(xintercept = 0.5, color=\"red\")\n```\n\n::: {.cell-output-display}\n![](JointAnalyses-2ab-Ven_files/figure-html/unnamed-chunk-4-1.png){width=864}\n:::\n:::\n\n\n\n\n\nPlot RT collapsed over list-length and experiment, as a function of serial position relative to N. Position 0 means the 2nd item in recall2 condition or the 4th item in the recall4 condition.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Means for plot, with within-participant SEMs\ngraphRT <- procTrim %>% \n  filter(procPeriod == \"Load\") %>% \n  summarySEwithin(measurevar = \"rt\", withinvars = c(\"recallamount\", \"serial_position_rel\"), idvar=\"participant\") %>% \n  mutate(serial_position_rel = as.numeric(as.character(serial_position_rel)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAutomatically converting the following non-factors to factors: serial_position_rel\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(graphRT, aes(serial_position_rel, rt)) + \n  geom_point(data = graphRT, mapping = aes(x = serial_position_rel, y = rt, color=as.factor(recallamount), group=as.factor(recallamount)), size = 2, alpha = 1/3) +\n  geom_line(data = graphRT, mapping = aes(x = serial_position_rel, y = rt, color=as.factor(recallamount), group=as.factor(recallamount))) + \n  geom_errorbar(aes(ymin=rt-se, ymax=rt+se, color=as.factor(recallamount), group=as.factor(recallamount)), width=.15)+\n  scale_colour_manual(values = viridisLite::viridis(2, direction = -1), name=\"List Length\") + \n  xlab(\"Relative Serial Position\") + \n  ylab(\"Mean Response Time (ms)\") +\n  # scale_y_continuous(breaks=seq(600, 1400, 50), limits = c(600, 1400))+\n  #ylim(250, 800) +\n  theme(axis.text.x = element_text(angle = 70, hjust=1))+\n  geom_vline(xintercept = 0.5, color=\"red\")\n```\n\n::: {.cell-output-display}\n![](JointAnalyses-2ab-Ven_files/figure-html/unnamed-chunk-5-1.png){width=480}\n:::\n:::\n\n\n\n\n## Traditional lmer analysis for quick fit\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!file.exists(R_output_file)) {\n  mldat <- filter(procTrim, procPeriod == \"Load\", serial_position_rel >= 1) %>% \n    mutate(ListLength = as.numeric(as.character(ListLength)))\n  \n  ml1 <- lmer(rt ~ exp + ListLength + recallamount + (1|participant), data=mldat)\n  ml2 <- lmer(rt ~ exp + ListLength + recallamount + serial_position_rel + (1|participant), data=mldat)\n  ml3 <- lmer(rt ~ exp + ListLength + recallamount + recallamount*serial_position_rel + (1|participant), data=mldat)\n}\n\nanova(ml1, ml2, ml3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrefitting model(s) with ML (instead of REML)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nData: mldat\nModels:\nml1: rt ~ exp + ListLength + recallamount + (1 | participant)\nml2: rt ~ exp + ListLength + recallamount + serial_position_rel + (1 | participant)\nml3: rt ~ exp + ListLength + recallamount + recallamount * serial_position_rel + (1 | participant)\n    npar    AIC    BIC  logLik deviance  Chisq Df Pr(>Chisq)    \nml1    6 206384 206429 -103186   206372                         \nml2    7 206329 206382 -103157   206315 56.765  1  4.912e-14 ***\nml3    8 206326 206387 -103155   206310  4.902  1    0.02682 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ml2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML ['lmerMod']\nFormula: rt ~ exp + ListLength + recallamount + serial_position_rel +      (1 | participant)\n   Data: mldat\n\nREML criterion at convergence: 206283.4\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-6.3355 -0.4196 -0.1080  0.2537  7.9642 \n\nRandom effects:\n Groups      Name        Variance Std.Dev.\n participant (Intercept) 180716   425.1   \n Residual                 99315   315.1   \nNumber of obs: 14339, groups:  participant, 120\n\nFixed effects:\n                     Estimate Std. Error t value\n(Intercept)          948.1679    56.6966  16.724\nexp2b               -400.0325    77.8066  -5.141\nListLength            -0.9874     2.1615  -0.457\nrecallamount4         13.6958     5.5575   2.464\nserial_position_rel   16.8199     2.2304   7.541\n\nCorrelation of Fixed Effects:\n            (Intr) exp2b  LstLng rcllm4\nexp2b       -0.686                     \nListLength  -0.221 -0.001              \nrecallamnt4 -0.004  0.001 -0.198       \nsrl_pstn_rl  0.038  0.000 -0.509  0.199\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ml3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML ['lmerMod']\nFormula: rt ~ exp + ListLength + recallamount + recallamount * serial_position_rel +      (1 | participant)\n   Data: mldat\n\nREML criterion at convergence: 206273.9\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-6.3202 -0.4185 -0.1087  0.2524  7.9618 \n\nRandom effects:\n Groups      Name        Variance Std.Dev.\n participant (Intercept) 180676   425.1   \n Residual                 99288   315.1   \nNumber of obs: 14339, groups:  participant, 120\n\nFixed effects:\n                                   Estimate Std. Error t value\n(Intercept)                        940.7041    56.7904  16.564\nexp2b                             -400.1547    77.7980  -5.144\nListLength                          -0.9887     2.1612  -0.457\nrecallamount4                       35.1675    11.1779   3.146\nserial_position_rel                 19.7417     2.5914   7.618\nrecallamount4:serial_position_rel   -9.0990     4.1100  -2.214\n\nCorrelation of Fixed Effects:\n            (Intr) exp2b  LstLng rcllm4 srl_p_\nexp2b       -0.685                            \nListLength  -0.221 -0.001                     \nrecallamnt4 -0.053  0.000 -0.099              \nsrl_pstn_rl  0.003  0.000 -0.438  0.527       \nrcllmnt4:__  0.059  0.001  0.000 -0.868 -0.509\n```\n\n\n:::\n:::\n\n\n\n### BRMS ANALYSES  \n\nFit the preregistered BRMS models. \n\nModel 1 is the model that predicts no increase after position N+1\nModel 2 predicts an equal increase after position N+1 for both recall2 and recall4 condition\nModel 3 includes an interactions between relative position and recall2 vs recall4\n\nFirst, to use the default priors, we need to transform the DV and IVS. DV is log transformed because RTs are skewed, and then z transformed. Continuous predictiors are also z transformed, while categorical predictions are set to sum contrasts.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!file.exists(R_output_file)) {\n  bmldat <- mldat %>% \n    mutate(rt = scale(log(rt))[,1],\n           ListLength = scale(ListLength)[,1],\n           serial_position_rel = scale(serial_position_rel)[,1],\n           exp = as.factor(exp))\n  \n  contrasts(bmldat$recallamount) <- \"contr.sum\"\n  contrasts(bmldat$exp) <- \"contr.sum\"\n  \n  \n  bml1 <- brm(rt ~ exp + ListLength + recallamount + (1|participant), data=bmldat, \n             save_all_pars = TRUE, iter = 40000, cores = 4, chains = 4)\n  bml2 <- brm(rt ~ exp + ListLength + recallamount + serial_position_rel + (1|participant), data=bmldat, \n             save_all_pars = TRUE, iter = 40000, cores = 4, chains = 4)\n  bml3 <- brm(rt ~ exp + ListLength + recallamount + serial_position_rel*recallamount + (1|participant), data=bmldat, \n             save_all_pars = TRUE, iter = 40000, cores = 4, chains = 4)\n}\n```\n:::\n\n\n\n\nView the estimates of the full model:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bml3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: rt ~ exp + ListLength + recallamount + serial_position_rel * recallamount + (1 | participant) \n   Data: bmldat (Number of observations: 14339) \n  Draws: 4 chains, each with iter = 40000; warmup = 20000; thin = 1;\n         total post-warmup draws = 80000\n\nMultilevel Hyperparameters:\n~participant (Number of levels: 120) \n              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(Intercept)     0.66      0.04     0.58     0.75 1.00     2694     6009\n\nRegression Coefficients:\n                                  Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept                             0.07      0.06    -0.05     0.19 1.00      796     1884\nexp1                                  0.50      0.06     0.38     0.62 1.01      817     1791\nListLength                           -0.00      0.01    -0.01     0.01 1.00    29036    47530\nrecallamount1                        -0.01      0.01    -0.02     0.00 1.00    35887    48612\nserial_position_rel                   0.05      0.01     0.03     0.06 1.00    27690    44198\nrecallamount1:serial_position_rel     0.01      0.01     0.00     0.02 1.00    35557    49379\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.58      0.00     0.58     0.59 1.00    40467    50082\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\n\nCompute bayes factors via bridge sampling:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(5236)\n\nif (!file.exists(R_output_file)) {\n  BF21 <- bayes_factor(bml2, bml1)\n  BF32 <- bayes_factor(bml3, bml2)\n}\n\nBF21\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEstimated Bayes factor in favor of bml2 over bml1: 522765483334965.93750\n```\n\n\n:::\n\n```{.r .cell-code}\nBF32\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEstimated Bayes factor in favor of bml3 over bml2: 0.20207\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# save.image(here::here('output/exp2.RData'))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}